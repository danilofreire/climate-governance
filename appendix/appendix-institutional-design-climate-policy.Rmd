---
title: |
       | Supplementary Materials for "Institutional Design and Elite Support for Climate Policies: Evidence from Latin American Countries"
author: 
- "Danilo Freire[^freire]"
- "Umberto Mignozzetti[^mignozzetti]"
- "David Skarbek[^skarbek]"
date: July 22, 2019
fontfamily: libertine
fontawesome: yes
fontsize: 12pt
monospace-url: yes
spacing: double
papersize: a4paper
bibliography: references.bib
biblio-style: apalike
output:
  pdf_document:
    citation_package: natbib
    fig_caption: yes
    number_sections: yes
    toc: true
    keep_tex: no
    template: template.latex
---

[^freire]: Postdoctoral Research Associate, The Political Theory Project, Brown University, Providence, RI 02912, USA, <danilofreire@brown.edu>, <http://danilofreire.github.io>. Corresponding author.

[^mignozzetti]: School of International Relations, Fundação Getulio Vargas, São Paulo, SP, Brazil and Wilf Family Department of Politics, NYU, NY, USA, [umberto.mig@nyu.edu](mailto:umberto.mig@nyu.edu), <http://umbertomig.com>.

[^skarbek]: The Department of Political Science and the Political Theory Project, Brown University, Providence, RI, USA, <davidskarbek@brown.edu>, <http://davidskarbek.com>.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(plm); library(tidyverse)
library(haven); library(clusterSEs)
library(stargazer); library(cjoint)
library(sp); library(cregg)
library(kableExtra)
load('freire-mignozzetti-skarbek.RData')

plot_mm <- function(
  x,
  group = attr(x, "by"),
  feature_headers = TRUE,
  header_fmt = "%s",
  size = 2,
  xlab = "Marginal Mean",
  ylab = "",
  legend_title = if (is.null(group)) "Feature" else group,
  legend_pos = "bottom",
  xlim = NULL,
  vline = 0,
  vline_color = "gray",
  theme = ggplot2::theme_bw(),
  ...
) {
  
  # function used in cj and ammplot to produce "fancy" feature labels
  clean_feature_labels <- function(data, RHS, feature_labels) {
    if (inherits(data, "cj_df") | inherits(data, "data.frame")) {
      fancy_labels <- stats::setNames(lapply(data[RHS], attr, "label"), RHS)
    } else if (inherits(data, "survey.design")) {
      fancy_labels <- stats::setNames(lapply(data[["variables"]][RHS], attr, "label"), RHS)
    } else {
      stop("'data' is not a 'data.frame' or 'survey.design' object")
    }
    ## check `feature_labels`, if present
    missing_labels <- RHS[!RHS %in% names(feature_labels)]
    feature_labels <- c(feature_labels, stats::setNames(rep(list(NULL), length(missing_labels)), missing_labels))
    ## clean fancy labels (use variable name if variable has no "label" attribute)
    for (i in seq_along(feature_labels)) {
      if (is.null(feature_labels[[i]]) || feature_labels[[i]] == "") {
        if (is.null(fancy_labels[[RHS[i]]])) {
          feature_labels[[i]] <- RHS[i]
        } else {
          feature_labels[[i]] <- fancy_labels[[RHS[i]]]
        }
      }
    }
    return(feature_labels)
  }
  
  # function to cleanup term labels (due to factor variable blah blah)
  clean_term_names <- function(x, RHS) {
    out <- data.frame(feature = character(length(x)), 
                      level = character(length(x)), 
                      stringsAsFactors = FALSE)
    for (i in seq_along(RHS)) {
      w <- grepl(RHS[i], x)
      out$feature[w] <- RHS[i]
      out$level[w] <- sub(paste0("^`?", RHS[i], "`?"), "", x[w])
    }
    
    # check whether levels are all unique
    if (any(duplicated(out$level))) {
      warning("Some level labels are duplicated across features. This may cause problems!")
    }
    
    return(out)
  }
  
  # function used to produce a data frame of features and levels
  make_term_labels_df <- function(data, feature_names, level_order = c("ascending", "descending")) {
    # setup data
    if (inherits(data, "data.frame")) {
      term_levels_list <- lapply(data[feature_names], levels)
    } else if (inherits(data, "survey.design")) {
      term_levels_list <- lapply(data[["variables"]][feature_names], levels)
    } else {
      stop("'data' is not a 'data.frame' or 'survey.design' object")
    }
    
    # figure out level order
    level_order <- match.arg(level_order)
    if (level_order == "descending") {
      term_levels_list[] <- lapply(term_levels_list, rev)
    }
    
    # construct data frame
    term_levels <- rev(unlist(term_levels_list))
    term_labels <- stats::setNames(rep(feature_names, lengths(term_levels_list)), rev(term_levels))
    data.frame(feature = unlist(term_labels), level = unlist(names(term_labels)), stringsAsFactors = FALSE)
  }
  
  # function used in plot() methods to make pretty feature headers
  make_feature_headers <- function(x, fmt = "(%s)") {
    feature_levels <- rev(split(x$level, x$feature))
    for (i in seq_along(feature_levels)) {
      feature_levels[[i]] <- levels(x$level)[match(feature_levels[[i]], levels(x$level))]
      feature_levels[[i]] <- c(feature_levels[[i]], sprintf(fmt, names(feature_levels)[i]))
    }
    factor(as.character(x$level), levels = unique(unname(unlist(feature_levels))))
  }
  
  # function used to check whether, if specified, the 'feature_order' argument is valid
  check_feature_order <- function(feature_order, RHS) {
    if (!is.null(feature_order)) {
      if (length(RHS) > length(feature_order)) {
        stop("'feature_order' appears to be missing values")
      } else if (length(RHS) < length(feature_order)) {
        stop("'feature_order' appears to have excess values")
      } else if (any(!names(feature_order) %in% RHS)) {
        stop("'feature_order' appears to contain erroneous values")
      }
    } else {
      feature_order <- RHS
    }
    return(feature_order)
  }
  
  # optionally, add gaps between features
  if (isTRUE(feature_headers)) {
    x$level <- make_feature_headers(x, fmt = header_fmt)
    to_merge <- data.frame(feature = unique(x$feature), level = sprintf(header_fmt, unique(x$feature)))
    if ("BY" %in% names(x)) {
      to_merge <- do.call("rbind", lapply(unique(x[["BY"]]), function(lev) {
        to_merge[["BY"]] <- lev
        to_merge
      }))
    } else if (!is.null(group)) {
      to_merge <- do.call("rbind", lapply(unique(x[[group]]), function(lev) {
        to_merge[[group]] <- lev
        to_merge
      }))
    }
    x <- merge(x, to_merge, all = TRUE)
  }
  
  if (is.null(group)) {
    p <- ggplot2::ggplot(data = x, ggplot2::aes_string(x = "estimate", y = "level", colour = "feature"))
  } else {
    p <- ggplot2::ggplot(data = x, ggplot2::aes_string(x = "estimate", y = "level", colour = group, group = group))
  }
  
  if (is.null(xlim)) {
    xmin <- min(x$lower, na.rm = TRUE)
    xmin <- if (xmin < 0) 1.04*xmin else .96*xmin
    xmax <- max(x$upper, na.rm = TRUE)
    xmax <- if (xmax > 0) 1.04*xmax else .96*xmax
    xlim <- c(xmin, xmax)
  }
  
  if (!is.null(vline)) {
    p <- p + ggplot2::geom_vline(xintercept = vline, colour = vline_color)
  }
  
  ggplotColours <- function(n = 6, h = c(0, 360) + 15){
    if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
    hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
  }
  myColors <- ggplotColours(length(unique(x$feature)))
  myColors <- c(rep(myColors[1], 6), rep(myColors[2], 5),
                rep(myColors[3], 4), rep(myColors[4], 5),
                rep(myColors[5], 6), rep(myColors[6], 6))
  myFaces <- c(rep('plain', 5), "bold",
               rep('plain', 4), "bold",
               rep('plain', 3), "bold",
               rep('plain', 4), "bold",
               rep('plain', 5), "bold",
               rep('plain', 5), "bold")
  mySizes <-  c(rep(10, 5), 11,
               rep(10, 4), 11,
               rep(10, 3), 11,
               rep(10, 4), 11,
               rep(10, 5), 11,
               rep(10, 5), 11)
  myColors <- rep(myColors, ifelse(length(unique(x[,group])), length(unique(x[,group])), 1))
  
  p <- p + ggplot2::geom_point(position = ggstance::position_dodgev(height = 0.75), 
                               size = size, na.rm = TRUE, color = myColors) +
    ggplot2::geom_errorbarh(ggplot2::aes_string(xmin = "lower", xmax = "upper"),  
                            size = 0.7, height = 0, na.rm = TRUE, color = myColors,
                            position = ggstance::position_dodgev(height = 0.75))
  if (is.null(group)) {
    p <- p + ggplot2::scale_colour_discrete(guide = ggplot2::guide_legend(title = legend_title))
  } else {
    p <- p + ggplot2::scale_colour_discrete(breaks = levels(x[[group]]),
                                            labels = levels(x[[group]]),
                                            guide = ggplot2::guide_legend(title = legend_title))
  }
  p <- p + theme_bw() +
    ggplot2::scale_x_continuous(limits = xlim, oob = scales::rescale_none) +
    ggplot2::xlab(xlab) + 
    ggplot2::ylab(ylab) + 
    theme + ggplot2::theme(
      legend.position = legend_pos,
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      axis.text.y = element_text(face=myFaces, size = mySizes)
    ) + 
    ggplot2::guides(colour = ggplot2::guide_legend(title = legend_title))
  return(p)
}

plotAMCE <- 
  function (x, main = "", xlab = "Change in E[Y]", 
            ci = 0.95, colors = NULL, 
            xlim = NULL, breaks = NULL, 
            labels = NULL, attribute.names = NULL, 
            level.names = NULL, label.baseline = TRUE, 
            text.size = 11, 
            text.color = "black", 
            point.size = 0.5, dodge.size = 0.9, 
            plot.theme = NULL, plot.display = "all", 
            facet.names = NULL, 
            facet.levels = NULL, 
            group.order = NULL, font.family = NULL, 
            tblfy = F, ...) {
    amce_obj <- x
    ylim <- xlim
    pe <- NULL
    se <- NULL
    group <- NULL
    lower <- NULL
    upper <- NULL
    var <- NULL
    printvar <- NULL
    facet <- NULL
    raw_attributes <- names(amce_obj$estimates)
    raw_levels <- lapply(amce_obj$estimates, colnames)
    for (effect in names(raw_levels)) {
        effect_elements <- strsplit(effect, ":")[[1]]
        baseline_interactions <- c()
        for (elem in effect_elements) {
            base_coef <- paste(c(elem, amce_obj$baselines[[elem]]), 
                collapse = "")
            baseline_interactions <- c(baseline_interactions, 
                base_coef)
        }
        interaction_str <- paste(baseline_interactions, sep = "", 
            collapse = ":")
        raw_levels[[effect]] <- c(interaction_str, raw_levels[[effect]])
    }
    if (ci < 1 & ci > 0) {
        zscr <- qnorm(1 - ((1 - ci)/2))
    }
    else {
        cat("Invalid confidence interval -- Defaulting to 95%")
        zscr <- qnorm(1 - ((1 - 0.95)/2))
    }
    if (!is.null(attribute.names)) {
        attribute.names <- unique(attribute.names)
        if (length(attribute.names) != length(raw_attributes)) {
            cat(paste("Error: The number of unique elements in attribute.names ", 
                length(attribute.names), " does not match the attributes in amce object for which estimates were obtained: ", 
                paste(raw_attributes, collapse = ", "), "\n", 
                sep = ""))
            cat("Defaulting attribute.names to attribute names in AMCE object\n")
            attribute.names <- NULL
        }
    }
    if (!is.null(level.names)) {
        names(level.names) <- clean.names(names(level.names))
        for (name in names(level.names)) {
            if (name %in% names(raw_levels)) {
                if (length(level.names[[name]]) != length(raw_levels[[name]])) {
                  cat(paste("Error: level.names lengths do not match levels for attribute ", 
                    name, "\n", sep = ""))
                  cat(paste("Defaulting level.names for attribute ", 
                    name, " to level names in AMCE object", "\n", 
                    sep = ""))
                  level.names[[name]] <- NULL
                }
            }
            else {
                cat(paste("Error: level.names entry ", name, 
                  " not in AMCE object. Removing level.names for attribute.", 
                  "\n", sep = ""))
                level.names[[name]] <- NULL
            }
        }
    }
    if (is.null(attribute.names)) {
        attribute.names <- c()
        for (attr in names(amce_obj$estimates)) {
            attr_split <- strsplit(attr, ":")[[1]]
            attr_lookup <- paste(unlist(sapply(attr_split, function(x) amce_obj$user.names[x])), 
                collapse = ":")
            attribute.names <- c(attribute.names, attr_lookup)
        }
    }
    if (is.null(level.names)) 
        level.names <- list()
    if (any(!names(raw_levels) %in% names(level.names))) {
        for (attr in names(raw_levels)[!names(raw_levels) %in% 
            names(level.names)]) {
            attr_split <- strsplit(raw_levels[[attr]], ":")
            level.names[[attr]] <- unlist(lapply(attr_split, 
                function(x) paste(sapply(x, function(y) amce_obj$user.levels[y]), 
                  collapse = ":")))
        }
    }
    plot.display.opts <- c("all", "unconditional", "interaction")
    if (!is.element(plot.display, plot.display.opts)) {
        stop(paste(c("Error-- plot.display must be once of: ", 
            paste(plot.display.opts, collapse = ", ")), collapse = " "))
    }
    if (!is.null(facet.names)) {
        facet.names <- clean.names(facet.names)
    }
    else if (!is.null(facet.levels)) {
        facet.names <- clean.names(names(facet.levels))
    }
    if (!is.null(facet.names)) {
        facet.names.check <- c()
        for (facet.name in facet.names) {
            if (grepl(":", facet.name)) 
                stop("Error-- cannot facet by interaction in current version.")
            if (!facet.name %in% names(amce_obj$estimates) & 
                !facet.name %in% names(amce_obj$cond.estimates)) {
                stop(paste(c("Error-- cannot find facet name", 
                  facet.name, "in AMCE object output."), collapse = " "))
            }
            else {
                facet.names.check <- c(facet.names.check, facet.name)
            }
        }
        facet.names <- facet.names.check
    }
    if ((is.null(facet.names)) & (length(amce_obj$respondent.varying) > 
        0) & (plot.display != "unconditional")) {
        facet.names <- amce_obj$respondent.varying
    }
    if (is.null(facet.names) & plot.display == "interaction") {
        warning("Warning: no facet name or respondent varying characteristic provided to calculate conditional estimates. Will display unconditional only")
        plot.display <- "unconditional"
    }
    if (plot.display == "unconditional" & !is.null(facet.names)) {
        warning("Warning-- plot display is set to unconditional, facet names will be ignored")
        facet.names <- NULL
        facet.levels <- NULL
    }
    if (!is.null(facet.levels)) {
        names(facet.levels) <- clean.names(names(facet.levels))
        for (facet.name in names(facet.levels)) {
            if (facet.name %in% names(amce_obj$baselines)) {
                facet.levels[[facet.name]] <- clean.names(facet.levels[[facet.name]])
                if (facet.name %in% names(amce_obj$estimates) && 
                  is.element(amce_obj$baselines[[facet.name]], 
                    facet.levels[[facet.name]])) {
                  stop(paste(c("Error: Facet level \"", as.character(amce_obj$baselines[[facet.name]]), 
                    "\" is the baseline level of a profile varying attribute. Please provide alternative facet level or use defaults."), 
                    collapse = ""))
                }
                if (is.null(names(facet.levels[[facet.name]]))) {
                  fac.levs <- sapply(facet.levels[[facet.name]], 
                    function(x) paste(facet.name, x, sep = ""))
                  names(facet.levels[[facet.name]]) <- sapply(fac.levs, 
                    USE.NAMES = F, function(x) amce_obj$user.levels[[x]])
                }
            }
            else if (is.null(names(facet.levels[[facet.name]]))) {
                names(facet.levels[[facet.name]]) <- as.character(facet.levels[[facet.name]])
            }
        }
    }
    if (is.null(facet.levels)) 
        facet.levels <- list()
    if (any(!facet.names %in% names(facet.levels))) {
        for (facet.name in facet.names[!facet.names %in% names(facet.levels)]) {
            if (facet.name %in% names(amce_obj$baselines)) {
                if (facet.name %in% names(amce_obj$estimates)) {
                  fac.levs <- colnames(amce_obj$estimates[[facet.name]])
                }
                else {
                  fac.levs <- colnames(amce_obj$cond.estimates[[facet.name]])
                }
                facet.levels[[facet.name]] <- sub(facet.name, 
                  "", fac.levs)
                facet.levels[[facet.name]] <- c(amce_obj$baselines[[facet.name]], 
                  facet.levels[[facet.name]])
                fac.levs <- c(paste(facet.name, amce_obj$baselines[[facet.name]], 
                  sep = ""), fac.levs)
                names(facet.levels[[facet.name]]) <- sapply(fac.levs, 
                  USE.NAMES = F, function(x) amce_obj$user.levels[[x]])
            }
            else if (facet.name %in% names(amce_obj$continuous)) {
                facet.levels[[facet.name]] <- amce_obj$continuous[[facet.name]]
            }
        }
    }
    covariate.values <- list()
    for (var in names(facet.levels)) {
        if (var %in% amce_obj$respondent.varying) {
            covariate.values[[var]] <- facet.levels[[var]]
        }
    }
    d <- data.frame(pe = c(), se = c(), upper = c(), lower = c(), 
        var = c(), printvar = c(), group = c(), facet = c())
    if (plot.display != "interaction") {
        if (plot.display == "all") {
            uncond.facet.name <- "Unconditional"
        }
        else {
            uncond.facet.name <- NA
        }
        if (plot.display == "all" && !is.null(facet.names)) {
            attr_remove <- c()
            for (facet.name in facet.names[!is.element(facet.names, 
                amce_obj$respondent.varying)]) {
                attr_remove1 <- raw_attributes[grepl(":", raw_attributes)]
                attr_remove1 <- attr_remove1[grepl(facet.name, 
                  attr_remove1)]
                attr_remove <- c(attr_remove, attr_remove1)
            }
            raw_attributes <- raw_attributes[!is.element(raw_attributes, 
                attr_remove)]
        }
        for (i in 1:length(raw_attributes)) {
            attr_name <- raw_attributes[i]
            print_attr_name <- attribute.names[which(names(amce_obj$estimates) == 
                raw_attributes[i])]
            d_head <- data.frame(pe = NA, se = NA, upper = NA, 
                lower = NA, var = attr_name, printvar = paste(print_attr_name, 
                  ":", sep = ""), group = "<NA>", facet = uncond.facet.name)
            d <- rbind(d, d_head)
            for (j in 1:length(raw_levels[[attr_name]])) {
                level_name <- raw_levels[[attr_name]][j]
                print_level_name <- level.names[[attr_name]][j]
                if (j == 1) {
                  if (label.baseline) {
                    print_level_name <- paste("(Baseline = ", 
                      print_level_name, ")", sep = "")
                  }
                  d_lev <- data.frame(pe = NA, se = NA, upper = NA, 
                    lower = NA, var = level_name, printvar = paste("   ", 
                      print_level_name, sep = ""), group = print_attr_name, 
                    facet = uncond.facet.name)
                }
                else {
                  val_pe <- amce_obj$estimates[[attr_name]][1, 
                    level_name]
                  val_se <- amce_obj$estimates[[attr_name]][2, 
                    level_name]
                  upper_bnd <- val_pe + zscr * val_se
                  lower_bnd <- val_pe - zscr * val_se
                  d_lev <- data.frame(pe = val_pe, se = val_se, 
                    upper = upper_bnd, lower = lower_bnd, var = level_name, 
                    printvar = paste("   ", print_level_name, 
                      sep = ""), group = print_attr_name, facet = uncond.facet.name)
                }
                d <- rbind(d, d_lev)
            }
        }
    }
    if (plot.display != "unconditional" & !is.null(facet.names)) {
        for (facet.name in facet.names) {
            print_facet_name <- amce_obj$user.names[[facet.name]]
            all_req_vars <- attr(terms(amce_obj$formula), "term.labels")
            all_mod <- unlist(sapply(all_req_vars, function(x) {
                y <- strsplit(x, ":")[[1]]
                if (any(y == facet.name)) 
                  x
            }))
            all_mod <- unlist(sapply(all_mod, function(x) {
                subs <- strsplit(x, ":")[[1]]
                subs <- subs[is.element(subs, names(amce_obj$estimates))]
                subs <- subs[subs != facet.name]
                if (length(subs) > 0) 
                  paste(subs, collapse = ":")
            }))
            if (length(all_mod) == 0) {
                stop(paste(c("Error: Facet variable", facet.name, 
                  "not interacted with profile attributes"), 
                  collapse = " "))
            }
            all_mod <- unique(all_mod)
            if (is.element(facet.name, names(amce_obj$estimates))) {
                facet.start <- 2
            }
            else {
                facet.start <- 1
            }
            for (k in facet.start:length(facet.levels[[facet.name]])) {
                facet_lev <- facet.levels[[facet.name]][k]
                if (is.element(facet.name, names(amce_obj$estimates))) {
                  print_facet_level <- paste(c("ACIE", paste(c(print_facet_name, 
                    names(facet.levels[[facet.name]])[k]), collapse = " = ")), 
                    collapse = "\n")
                }
                else {
                  print_facet_level <- paste(c("Conditional on", 
                    paste(c(print_facet_name, names(facet.levels[[facet.name]])[k]), 
                      collapse = " = ")), collapse = "\n")
                }
                for (mod_var in all_mod) {
                  print_attr_name <- attribute.names[which(names(amce_obj$estimates) == 
                    mod_var)]
                  d_head <- data.frame(pe = NA, se = NA, upper = NA, 
                    lower = NA, var = mod_var, printvar = paste(print_attr_name, 
                      ":", sep = ""), group = "<NA>", facet = print_facet_level)
                  d <- rbind(d, d_head)
                  if (facet.name %in% names(amce_obj$estimates)) {
                    inter_coef <- paste(sort(c(mod_var, facet.name)), 
                      collapse = ":")
                    estimate.source <- amce_obj$estimates[[inter_coef]]
                    estimate.source <- estimate.source[, grep(paste0(facet.name, 
                      facet_lev), colnames(estimate.source))]
                  }
                  else {
                    estimate.source <- get.conditional.effects(amce_obj, 
                      covariate.values, facet.name, facet_lev, 
                      mod_var)
                  }
                  mod_vars <- strsplit(mod_var, ":")[[1]]
                  for (p in 1:length(raw_levels[[mod_var]])) {
                    mod_coef <- raw_levels[[mod_var]][p]
                    mod_coefs <- strsplit(mod_coef, ":")[[1]]
                    for (lev in 1:length(mod_coefs)) {
                      mod_lev <- sub(mod_vars[lev], "", mod_coefs[lev])
                    }
                    print_level_name <- level.names[[mod_var]][p]
                    if (p == 1) {
                      if (label.baseline) {
                        print_level_name <- paste("(Baseline = ", 
                          print_level_name, ")", sep = "")
                      }
                      d_lev <- data.frame(pe = NA, se = NA, upper = NA, 
                        lower = NA, var = mod_coef, printvar = paste("   ", 
                          print_level_name, sep = ""), group = print_attr_name, 
                        facet = print_facet_level)
                    }
                    else {
                      val_pe <- estimate.source[1, p - 1]
                      if (!is.na(val_pe)) {
                        val_se <- estimate.source[2, p - 1]
                        upper_bnd <- val_pe + zscr * val_se
                        lower_bnd <- val_pe - zscr * val_se
                      }
                      else {
                        val_se <- upper_bnd <- lower_bnd <- NA
                      }
                      d_lev <- data.frame(pe = val_pe, se = val_se, 
                        upper = upper_bnd, lower = lower_bnd, 
                        var = mod_coef, printvar = paste("   ", 
                          print_level_name, sep = ""), group = print_attr_name, 
                        facet = print_facet_level)
                    }
                    d <- rbind(d, d_lev)
                  }
                }
            }
        }
    }
    else {
        d <- d[, -which(colnames(d) == "facet")]
    }
    if (is.null(ylim)) {
        max_upper <- max(d$upper, na.rm = T) + 0.05
        min_lower <- min(d$lower, na.rm = T) - 0.05
        ylim <- c(min_lower, max_upper)
        d[is.na(d)] <- max_upper + 100
    }
    else {
        d[is.na(d)] <- max(ylim) + 100
    }
    d$group[d$group == "<NA>"] <- NA
    if (!is.null(facet.names)) 
        d$facet[d$facet == "<NA>"] <- NA
    d$var <- factor(d$var, levels = unique(d$var)[length(d$var):1])
    if (!is.null(facet.names)) {
        d$facet <- factor(d$facet, levels = unique(d$facet))
    }
    if (!is.null(group.order)) {
        n.row <- length(unique(as.character(d$var)))
        order.var <- vector("character", length = n.row)
        i <- 1
        while (i < n.row) {
            for (j in group.order) {
                order.var[i] <- unique(as.character(d$var[d$var == 
                  gsub(" ", "", j)]))
                i <- i + 1
                temp.d <- d
                temp.d$group <- gsub(" ", "", temp.d$group)
                temp.d <- subset(temp.d, group == gsub(" ", "", 
                  j))
                temp.var <- unique((as.character(temp.d$var)))
                order.var[i:(i + length(temp.var) - 1)] <- temp.var
                i <- i + length(temp.var)
            }
        }
        order.var <- rev(order.var)
        order.df <- data.frame(order.var, 1:length(order.var))
        colnames(order.df) <- c("var", "order")
        d$var <- factor(d$var, levels = order.var)
        d <- merge(d, order.df, by.x = "var", by.y = "var", suffixes = c("", 
            ""))
    }
    levs <- as.character(d$printvar)
    levs <- gsub('organizations', 'organisations', levs)
    d$printvar <- factor(levs, levels = levs)
    if(tblfy) {
      return(d)
    }
    p = ggplot(d, aes(y = pe, x = var, colour = group))
    p = p + coord_flip(ylim = ylim)
    p = p + geom_hline(yintercept = 0, size = 0.5, colour = "black", 
        linetype = "dotted")
    p = p + geom_pointrange(aes(ymin = lower, ymax = upper), 
        position = position_dodge(width = dodge.size), size = point.size)
    if (!is.null(facet.names)) {
        p = p + facet_wrap(~facet)
    }
    if (is.null(breaks) & is.null(labels)) {
        p = p + scale_y_continuous(name = xlab)
    }
    else if (is.null(breaks) & !is.null(labels)) {
        p = p + scale_y_continuous(name = xlab, labels = labels)
    }
    else if (!is.null(breaks) & is.null(labels)) {
        p = p + scale_y_continuous(name = xlab, breaks = breaks)
    }
    else if (!is.null(breaks) & !is.null(labels)) {
        p = p + scale_y_continuous(name = xlab, breaks = breaks, 
            labels = labels)
    }
    if (!is.null(group.order)) {
        fix.xlabs.df <- d[!duplicated(d$var), ]
        fix.xlabs <- fix.xlabs.df[order(-fix.xlabs.df$order), 
            ]$printvar
    }
    else {
        fix.xlabs <- as.character(d$printvar)[!duplicated(d$var)]
    }
    p = p + scale_x_discrete(name = "", labels = fix.xlabs[length(fix.xlabs):1])
    if (!is.null(main)) {
        if (main != "") {
            p = p + ggtitle(main)
        }
    }
    if (is.null(colors)) {
        p = p + scale_colour_discrete(" ")
    }
    else if (is.vector(colors)) {
        cPal <- rep(colors, ceiling(length(unique(d$group))/length(colors)))
        p = p + scale_colour_manual(values = cPal)
    }
    else {
        cat("Error: 'colors' must be a vector. Using default colors\n")
        p = p + scale_colour_discrete(" ")
    }
    if (is.null(plot.theme)) {
        theme_bw1 <- function(base_size = text.size, base_family = "") {
            theme_grey(base_size = base_size, base_family = base_family) %+replace% 
                theme(axis.text.x = element_text(size = base_size * 
                  0.9, colour = text.color, hjust = 0.5, vjust = 1), 
                  axis.text.y = element_text(size = base_size, 
                    colour = text.color, hjust = 0, vjust = 0.5, 
                    family = font.family), axis.ticks = element_line(colour = "grey50"), 
                  axis.title.y = element_text(size = base_size, 
                    angle = 90, vjust = 0.01, hjust = 0.1, family = font.family), 
                  plot.title = element_text(face = "bold", family = font.family), 
                  legend.position = "none")
        }
        p = p + theme_bw1()
        print(p)
    }
    else if (is.null(class(plot.theme))) {
        cat("Error: 'plot.theme' is not a valid ggplot theme object. Using default theme\n")
        theme_bw1 <- function(base_size = text.size, base_family = "") {
            theme_grey(base_size = base_size, base_family = base_family) %+replace% 
                theme(axis.text.x = element_text(size = base_size * 
                  0.9, colour = text.color, hjust = 0.5, vjust = 1), 
                  axis.text.y = element_text(size = base_size, 
                    colour = text.color, hjust = 0, vjust = 0.5, 
                    family = font.family), axis.ticks = element_line(colour = "grey50"), 
                  axis.title.y = element_text(size = base_size, 
                    angle = 90, vjust = 0.01, hjust = 0.1, family = font.family), 
                  plot.title = element_text(face = "bold", family = font.family), 
                  legend.position = "none")
        }
        p = p + theme_bw1()
        print(p)
    }
    else if (class(plot.theme)[1] != "theme") {
        cat("Error: 'plot.theme' is not a valid ggplot theme object. Using default theme\n")
        theme_bw1 <- function(base_size = text.size, base_family = "") {
            theme_grey(base_size = base_size, base_family = base_family) %+replace% 
                theme(axis.text.x = element_text(size = base_size * 
                  0.9, colour = text.color, hjust = 0.5, vjust = 1), 
                  axis.text.y = element_text(size = base_size, 
                    colour = text.color, hjust = 0, vjust = 0.5, 
                    family = font.family), axis.ticks = element_line(colour = "grey50"), 
                  axis.title.y = element_text(size = base_size, 
                    angle = 90, vjust = 0.01, hjust = 0.1, family = font.family), 
                  plot.title = element_text(face = "bold", family = font.family), 
                  legend.position = "none")
        }
        p = p + theme_bw1()
        print(p)
    }
    else {
        p = p + plot.theme
        print(p)
    }
    if (length(covariate.values) > 1) {
        resp.message <- c("Note:")
        for (this.var in names(covariate.values)) {
            resp.message <- paste(c(resp.message, " For AMCE and ACIE conditional on ", 
                this.var, ", "), collapse = "")
            other.vars <- names(covariate.values)[names(covariate.values) != 
                this.var]
            other.levels <- c()
            for (var in other.vars) {
                other.levels <- c(other.levels, paste(c(var, 
                  " will be held at level \"", names(covariate.values[[var]])[1], 
                  "\""), collapse = ""))
            }
            other.levels <- paste(other.levels, collapse = ", and ")
            resp.message <- c(resp.message, other.levels, ".")
            resp.message <- paste(resp.message, collapse = "")
        }
        cat(resp.message, "\n")
    }
}

# Function
table_mm <- function(mms, capt) {
  dfr <- data.frame(feature = mms[,c(4)], 
             round(mms[,c(5,6,8,9,10)], digits=3))
  names(dfr) <- c('Feature', 'Estimate', 'Std.Error',
                'P-Value', 'Lower', 'Upper')
  return(kable(dfr, "latex", caption = capt, booktabs = T) %>%
    kable_styling(font_size = 10) %>%
    group_rows('Who makes the rules?', 1, 5) %>%
    group_rows('How are conflicts resolved?', 6, 10) %>%
    group_rows('What punishments do they use?', 11, 14) %>%
    group_rows('How are repeated violations punished?', 15, 17) %>%
    group_rows('How are costs distributed?', 18, 21) %>%
    group_rows('How often will the agreement be renegotiated?', 22, 26))
}

tableAMCE <- function(results, capt = 'Main Model') {
  aux <- plotAMCE(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Full Model',
     attribute.names = attrs, tblfy = T)
  aux <- aux %>%
    filter(!is.na(group))%>%
    select(printvar, pe, se, lower, upper)
  indx <- grep('Baseline =', aux$printvar)
  aux$pe <- round(aux$pe, digits = 3)
  aux$se <- round(aux$se, digits = 3)
  aux$lower <- round(aux$lower, digits = 3)
  aux$upper <- round(aux$upper, digits = 3)
  aux$pe[indx] = ''
  aux$se[indx] = ''
  aux$lower[indx] = ''
  aux$upper[indx] = ''
  names(aux) <- c('Feature', 'Estimate', 'Std.Error', 
                  'Lower', 'Upper')
  return(kable(aux, "latex", caption = capt, booktabs = T, align = c('l', rep('c', 4))) %>%
    kable_styling(font_size = 10) %>%
    group_rows('How are conflicts resolved?', 1, 5) %>%
    group_rows('How are costs distributed?', 6, 9) %>%
    group_rows('How are repeated violations punished?', 10, 12) %>%
    group_rows('How often will the agreement be renegotiated?', 13, 17) %>%
    group_rows('What punishments do they use?', 18, 21) %>%
    group_rows('Who makes the rules?', 22, 26))
}
```

# Latin American Elite Survey \label{sec:latam}

\setlength{\parindent}{1cm}
\setlength{\parskip}{0pt}

From October 1 to December 5, 2018, we run an elite survey with respondents from ten Latin American countries: Argentina, Bolivia, Brazil, Chile, Colombia, Costa Rica, Ecuador, Mexico, Panama, and Peru. The survey proceeded in two steps.

We collected information on Latin American elites. The target was:

1. Executive members
2. Legislative members
3. Civil society
4. Academics

For each profile, in each country, we aimed at surveying:

1. 10 Executive members
2. 10 Legislative members
3. 15 Civil society
4. 15 Academics

To do so, we build a prospective respondents dataset with ten times these members for each country. Then, we run an online and telephone survey where we collected information regarding the climate change agreements and other climate change related problems.

After finishing this dataset, we started the surveying stage. From November 12 to December 5, we ran the survey by contacting elite members by phone or by email. We had two teams of enumerators, one based in São Paulo and another based in Rio de Janeiro, Brazil, comprised of Portuguese and Spanish native speakers. Although the overall aim of the survey was 500 responses, the teams managed to collect 654 interviews.

# Conjoint Experiment Analysis: Identification and Estimation \label{sec:conjoint}

A conjoint experiment is a statistical technique that allows individuals to express their preferences on multiple attributes of a single topic [@hainmueller2014causal; @bansak2016economic]. Individuals are presented with two hypothetical scenarios, A and B, each containing a series of characteristics a researcher wants to evaluate. The individual chooses one of them. As the attributes are randomised and individuals choose between different pairs of hypothetical scenarios, we can estimate how individuals value each of the conjoined elements.  

In our research, we ask what features elite members would like to see implemented in a climate change agreement. We ask their opinion on 6 questions: 1) who makes the rules; 2) who enforces the laws; 3) what punishment should be used against lawbreakers; 4) how are repeated violations punished; 5) how are costs distributed, and 6) how often the agreement will be renegotiated. Each of the questions has four to five different attributes. For the first two questions, we ask individuals if they would rather have the community, local governments, federal governments, or international organisations to create or enforce rules. As for punishments, we have options ranging from do nothing to fines and incarceration. We ask whether the costs of climate change agreements should be paid mostly or exclusively by developed countries, by polluter countries regardless of their wealth, or if costs should be allocated according to the history of emissions of a given nation. Individuals also state their preferences for short-term agreements, a proxy we use for flexibility, or for long-term ones, what we see as a proxy for the stability of rules. Lastly, we ask which of the two conjoined choices individuals perceive as more legitimate and more efficient. 

Conjoint experiments have many advantages. First, as each individual chooses between many pairs of possible climate agreements -- seven in our case -- we can drastically increase our sample size without incurring in further financial costs. The design thus maximizes our research budget. Second, individuals rarely decide considering one attribute at a time, as presented in other types of survey experiments. In that regard, our conjoint analysis mirrors how people naturally make their choices, that is, by simultaneously taking several characteristics into consideration. Finally, as the experiments consist of a simple choice between A and B, conjoint analyses are easy to understand and to implement. This research design reduces the cognitive load interviewees have while answering surveys and as a result, we can expect more accurate responses from our sample.  

# Descriptive Statistics \label{sec:descstats}

The main demographic statistics collected were the country and elite types, and the geolocation of the respondents. They follow in the graphs below.

```{r demogGraph, echo=FALSE, fig.align='center', fig.height=3.5, message=FALSE,warning=F}
aux <- cj %>%
  select(Response.ID, countryOrigin, groupOrigin, LocationLongitude, LocationLatitude) %>%
  unique()

# Country
tab <- data.frame(table(aux$countryOrigin))
names(tab) <- c('Country', 'Frequency')
p<-ggplot(data=tab, aes(x = Country, y=Frequency)) +
  geom_bar(stat="identity") +
  geom_hline(yintercept=50, linetype="dashed", color = "black") + 
  theme_bw() + annotate(geom = "text", label = tab$Frequency,
                        x = tab$Country, y = tab$Frequency + 2)
p

# Elite type
tab <- data.frame(table(aux$groupOrigin))
names(tab) <- c('Group Origin', 'Frequency')
p<-ggplot(data=tab, aes(x = `Group Origin`, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + annotate(geom = "text", label = tab$Frequency,
                        x = tab$`Group Origin`, y = tab$Frequency + 5)
p
```

As we can see, we managed to contact more than fifty elite members for all countries but Bolivia and Peru. To compensate for the low collection rates in these two countries, note that we exceeded the sample size in all the remaining states.

Considering the elite type, note that we have, as expected, more people from academia and the civil society, followed by Executive and Legislative. The legislative collection was below the original target, but above the minimum mark of 5 for each country. This is expected, given the difficulty of accessing these elite members. 

In the map, we can see that the answers concentrate on the country's capitals, with some variation within the state, but with sample concentrated in the largest municipalities. This is also in line with our expectations, as elite members are assumed to gravitate around the capitals and the influence centers.

# Frequency of Features Selected by Each Attribute \label{sec:features}

The figures below display the freature frequency for each attribute, by each task.

```{r attributes, echo=FALSE, fig.align='center', fig.height=4}
aux <- cj %>%
  select(Response.ID, `Who makes the rules?`, `How are conflicts resolved?`, `What punishments do they use?`,`How are repeated violations punished?`, `How are costs distributed?`,`How often will the agreement be renegotiated?`) %>%
  unique()

# Who makes the rules
tab <- data.frame(table(aux$`Who makes the rules?`))
names(tab) <- c('Levels', 'Frequency')
p<-ggplot(data=tab, aes(x = Levels, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('Who makes the rules?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 35) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How are conflicts resolved?
tab <- data.frame(table(aux$`How are conflicts resolved?`))
names(tab) <- c('Levels', 'Frequency')
p<-ggplot(data=tab, aes(x = Levels, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How are conflicts resolved?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 35) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# What punishments do they use?
tab <- data.frame(table(aux$`What punishments do they use?`))
names(tab) <- c('Levels', 'Frequency')
p<-ggplot(data=tab, aes(x = Levels, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('What punishments do they use?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 40) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How are repeated violations punished?
tab <- data.frame(table(aux$`How are repeated violations punished?`))
names(tab) <- c('Levels', 'Frequency')
p<-ggplot(data=tab, aes(x = Levels, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How are repeated violations punished?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 50) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How are costs distributed?
tab <- data.frame(table(aux$`How are costs distributed?`))
names(tab) <- c('Levels', 'Frequency')
p<-ggplot(data=tab, aes(x = Levels, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How are costs distributed?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 50) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

# How often will the agreement be renegotiated?
tab <- data.frame(table(aux$`How often will the agreement be renegotiated?`))
names(tab) <- c('Levels', 'Frequency')
p<-ggplot(data=tab, aes(x = Levels, y=Frequency)) +
  geom_bar(stat="identity") +
  theme_bw() + xlab('How often will the agreement be renegotiated?') +
  annotate(geom = "text", label = tab$Frequency,
           x = tab$Levels, y = tab$Frequency + 50) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p
```

The two remarkable issues are the low frequency of *Less penalty* in the attribute *How are repeated violations punished?* and the low frequency of *None* for the attribute *What punishments do they use?*. This because when we draw the level none for the attribute *What punishments do they use?* or the level less penalty for *How are repeated violations punished?*, then it makes no sense to have less penalty than the minimum possible.

# Code for the Main Paper

The code for Figure 2 of the paper follows below, with also the point estimates in a companion table.

```{r codefig2}
## Main plot
# Main estimation equation
fm <- selected ~ `Who makes the rules?` +
  `How are conflicts resolved?` +
  `What punishments do they use?` + 
  `How are repeated violations punished?` +
  `How are costs distributed?` +
  `How often will the agreement be renegotiated?`

# Plot
mms <- mm(cj, fm, id = ~Response.ID, alpha = .1, h0=0.5)
p <- plot(mms, vline = 0.5)
p
ggsave(filename = 'MM_all.pdf', plot = p, width = 6, height = 5)

# Table
table_mm(mms, capt = 'Marginal Means -- Full Dataset')
```

The code for Figure 3 of the paper follows below, with also the point estimates in a companion table.

\newpage

```{r codefig3}
## Marginal means by Country

# Argentina
arg <- mm(subset(cj, countryOrigin=='Argentina'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(arg, capt = 'Marginal Means -- Argentina Only')
```

\newpage

```{r}
# Bolivia
bol <- mm(subset(cj, countryOrigin=='Bolivia'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(bol, capt = 'Marginal Means -- Bolivia Only')
```

\newpage

```{r}
# Brazil
bra <- mm(subset(cj, countryOrigin=='Brazil'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(bra, capt = 'Marginal Means -- Brazil Only')
```

\newpage

```{r}
# Chile
chi <- mm(subset(cj, countryOrigin=='Chile'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(chi, capt = 'Marginal Means -- Chile Only')
```

\newpage

```{r}
# Colombia
col <- mm(subset(cj, countryOrigin=='Colombia'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(col, capt = 'Marginal Means -- Colombia Only')
```

\newpage

```{r}
# Costa Rica
cri <- mm(subset(cj, countryOrigin=='Costa Rica'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(cri, capt = 'Marginal Means -- Costa Rica Only')
```

\newpage

```{r}
# Ecuador
ecu <- mm(subset(cj, countryOrigin=='Ecuador'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(ecu, capt = 'Marginal Means -- Ecuador Only')
```

\newpage

```{r}
# Mexico
mex <- mm(subset(cj, countryOrigin=='Mexico'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(mex, capt = 'Marginal Means -- Mexico Only')
```

\newpage

```{r}
# Panama
pan <- mm(subset(cj, countryOrigin=='Panama'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(pan, capt = 'Marginal Means -- Panama Only')
```

\newpage

```{r}
# Peru
per <- mm(subset(cj, countryOrigin=='Peru'),  
        fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(per, capt = 'Marginal Means -- Peru Only')
```

\newpage

```{r, fig.width = 10, fig.height = 10}
# Changing country labels
arg$country <- 'Argentina'
bol$country <- 'Bolivia'
bra$country <- 'Brazil'
chi$country <- 'Chile'
col$country <- 'Colombia'
cri$country <- 'Costa Rica'
ecu$country <- 'Ecuador'
mex$country <- 'Mexico'
pan$country <- 'Panama'
per$country <- 'Peru'
# Plot by country
p <- plot(rbind(arg, bol, bra, chi, col, 
              cri, ecu, mex, pan, per), 
        group = 'country', vline = 0.5, nr = 10) +
  facet_wrap( ~ country, ncol = 5)

p

ggsave(filename = 'MM_country.pdf', 
       plot = p, width = 12, height = 12)
```

The code for Figure 4 of the paper follows below, with also the point estimates in a companion table.

```{r}
## Elite type graphs and estimates

# Table for the Executive
res1 <- mm(subset(cj, groupOrigin=='Executive'), 
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res1, capt = 'Marginal Means -- Executive Only')
```

\newpage

```{r}
# Legislative
res2 <- mm(subset(cj, groupOrigin=='Legislative'), 
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res2, capt = 'Marginal Means -- Legislative Only')
```

\newpage

```{r}
# Civil Society
res3 <- mm(subset(cj, groupOrigin=='Civil Society'), 
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res3, capt = 'Marginal Means -- Civil Society Only')
```

\newpage

```{r}
# Academia
res4 <- mm(subset(cj, groupOrigin=='Academia'), 
           fm, id = ~Response.ID, alpha = 0.1, h0 = 0.5)
table_mm(res4, capt = 'Marginal Means -- Academia Only')

```

\newpage

```{r, fig.width = 7, fig.height = 8}
# Changing labels
res1$MemberType <- 'Executive'
res2$MemberType <- 'Legislative'
res3$MemberType <- 'Civil Society'
res4$MemberType <- 'Academia'

# Plot by Elite Type
p <- plot(rbind(res1, res2, res3, res4), 
     group = 'MemberType', vline = 0.5, nr=4) + 
  facet_wrap( ~ MemberType, ncol=4)
p

ggsave(filename = 'MM_membertype.pdf', plot = p, 
       width = 8, height = 5)
```

# Average Marginal Component Effect (AMCE) Estimator \label{sec:amce}

This estimator fixes one category and look at changes from this baseline category. Below follows the plots for the main model and the country and elite type subsamples.

```{r, fig.width = 7, fig.height = 8}
## Main model
rm(cj)
load('freire-mignozzetti-skarbek.RData')

# Set conjoint baselines
baselines <- list()
baselines$`How often will the agreement be renegotiated?` <- "One year"
baselines$`What punishments do they use?` <- 'None'
baselines$`How are conflicts resolved?` <- 'Government bureaucracy'
baselines$`How are costs distributed?` <- 'Rich countries pay more than poor countries'
baselines$`Who makes the rules?` <- 'Federal government'

attrs <- 
  c("Who makes the rules?",
    "How are conflicts resolved?",
    "What punishments do they use?",
    "How are repeated violations punished?",
    "How are costs distributed?",
    "How often will the agreement be renegotiated?")

results <- 
  cjoint::amce(fm, data=cj, cluster=T, 
               respondent.id="Response.ID", 
               design=conjDesign, 
               baselines = baselines, na.ignore = T)

# Table AMCE -- Full Model 
tableAMCE(results, capt = 'AMCE -- Full Model')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
# Plot AMCE -- Full Model
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Full Model',
     attribute.names = attrs)
```

\newpage

```{r}
## Country subsample

## Argentina
results <- cjoint::amce(fm, data=cj, cluster=TRUE,
                        respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Argentina')
# AMCE -- Argentina Only
tableAMCE(results, capt = 'AMCE -- Argentina Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Argentina Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Bolivia
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Bolivia')
# Table AMCE -- Full Model 
tableAMCE(results, capt = 'AMCE -- Bolivia Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Bolivia Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Brazil
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Brazil')
# Table AMCE -- Brazil Only
tableAMCE(results, capt = 'AMCE -- Brazil Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Brazil Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Chile
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Chile')
# Table AMCE -- Chile Only
tableAMCE(results, capt = 'AMCE -- Chile Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Chile Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Colombia
results <- cjoint::amce(fm, data=cj, cluster=TRUE, 
                        respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Colombia')
# Table AMCE -- Colombia Only
tableAMCE(results, capt = 'AMCE -- Colombia Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Colombia Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Costa Rica
results <- cjoint::amce(fm, data=cj, cluster=TRUE,
                        respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Costa Rica')
# Table AMCE -- Costa Rica Only
tableAMCE(results, capt = 'AMCE -- Costa Rica Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Costa Rica Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Ecuador
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Ecuador')
# Table AMCE -- Ecuador Only
tableAMCE(results, capt = 'AMCE -- Ecuador Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Ecuador Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Mexico
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Mexico')
# Table AMCE -- Full Model 
tableAMCE(results, capt = 'AMCE -- Mexico Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Mexico Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Panama
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Panama')
# Table AMCE -- Panama Only
tableAMCE(results, capt = 'AMCE -- Panama Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Panama Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Peru
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$countryOrigin=='Peru')
# Table AMCE -- Peru Only
tableAMCE(results, capt = 'AMCE -- Peru Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Peru Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Elite Subsample

# Executive
results <- cjoint::amce(fm, data=cj, cluster=TRUE,
                        respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$groupOrigin=='Executive')
# Table AMCE -- Executive Only
tableAMCE(results, capt = 'AMCE -- Executive Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Executive Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Legislative
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$groupOrigin=='Legislative')
# Table AMCE -- Legislative Only
tableAMCE(results, capt = 'AMCE -- Legislative Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Legislative Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Civil society
results <- cjoint::amce(fm, data=cj, cluster=TRUE, 
                        respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = (cj$groupOrigin=='Civil Society'))
# Table AMCE -- Civil Society Only 
tableAMCE(results, capt = 'AMCE -- Civil Society Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Civil Society Only',
     attribute.names = attrs)
```

\newpage

```{r}
## Academia Only
results <- cjoint::amce(fm, data=cj, cluster=TRUE, respondent.id="Response.ID", 
                        design=conjDesign, baselines = baselines,
                        subset = cj$groupOrigin=='Academia')
# Table AMCE -- Full Model 
tableAMCE(results, capt = 'AMCE -- Academia Only')
```

\newpage

```{r, fig.width = 7, fig.height = 8}
plot(results, ci=0.9, point.size = .8, dodge.size = 1,
     text.size = 10, main = 'AMCE -- Academia Only',
     attribute.names = attrs)
```

\newpage

# APSA Experimental Section Standard Report for Experiments

## Hypothesis

The experiment was designed to study the characteristics of the climate change mitigation treaties favored by Latin American elites.

## Subjects and Context

The eligibility criteria for the research was to belong to one of the four elite profiles listed below.

1. **Executive members**: members of regulatory agencies, politicians (mayors, governors, presidents), members of ministries and secretaries at the federal and state levels.
2. **Legislative members**: legislators and staff officers from the federal and state level in the researched countries.
3. **Civil society**: environmental and energy-related NGO members; oil, renewables, and environmental solutions firm owners in the researched countries.
4. **Academics**: professors from energy and engineering departments of the most prestigious universities in the countries researched.

We decided to include these profiles based on the stakes and influence that such elites have on climate change policies. According to the IR constructivist theories, academics have notable influence on our topic of interest as they form the epistemic community around climate change policies. Civil society members that have stakes on climate policies are also influential, such as oil-extracting companies, lobby groups, and environmental NGOs. Executive and Legislative elites handle the decisions themselves, so their importance.

We selected ten countries to our sample: Argentina, Bolivia, Brazil, Chile, Colombia, Costa Rica, Ecuador, Mexico, Panama, and Peru. Our selection criteria were the impact of climate change on each nation, their size and regional importance, and natural resources availability. For each country, we built a dataset of potential respondents with at least:

* 150 potential legislative respondents
* 150 potential executive respondents
* 200 potential civil society respondents
* 200 potential academic respondents

These numbers represent ten times the number of respondents we were aiming to interview by the end of the survey. The dataset was build from October 5th to November 12th, 2018. We hired a team of enumerators that searched the internet for people in the countries that fulfilled our pre-determined elite profiles.

We ranked the possible respondents in two tiers. In the first tier we placed people that we had complete information about their profiles: office telephone numbers, emails, social media contacts, and so on. In the second tier we included participants that had incomplete profiles, such as those with only online information available. The dataset including the first-tier respondents was randomly divided between enumerators in Rio de Janeiro and São Paulo to avoid any eventual biases from the collecting stage. Both groups conducted the interviews by phone from November 12th to December 5th, 2018. The second tier dataset was used for an online only version of the survey.

The response rate in each of the enumeration sites and in the online only survey follows in the table below.

\vspace{.5cm}

| Country    | Enumeration Place | Type             | Total | Phone  | Online |
|:-----------|:------------------|:-----------------|------:|-------:|-------:|
| Argentina  | Rio de Janeiro    | Online and Phone | 300   | 33     | 17     |
| Bolivia    | Rio de Janeiro    | Online and Phone | 372   | 31     | 11     |
| Brazil     | Rio de Janeiro    | Online and Phone | 346   | 34     | 12     |
| Chile      | Rio de Janeiro    | Online and Phone | 417   | 35     | 12     |
| Colombia   | Rio de Janeiro    | Online and Phone | 445   | 35     | 21     |
| Costa Rica | Rio de Janeiro    | Online and Phone | 409   | 32     | 11     |
| Ecuador    | Rio de Janeiro    | Online and Phone | 512   | 30     | 12     |
| Mexico     | Rio de Janeiro    | Online and Phone | 468   | 41     | 17     |
| Panama     | Rio de Janeiro    | Online and Phone | 291   | 30     | 14     |
| Peru       | Rio de Janeiro    | Online and Phone | 243   | 32     | 11     |
| *TOTAL*    |                   | Online and Phone | 3803  | 333    | 138    |
|            |                   |                  |       |        |        |
| Argentina  | Sao Paulo         | Online and Phone | 292   | 48     | 16     |
| Bolivia    | Sao Paulo         | Online and Phone | 373   | 50     | 13     |
| Brazil     | Sao Paulo         | Online and Phone | 344   | 43     | 15     |
| Chile      | Sao Paulo         | Online and Phone | 416   | 41     | 15     |
| Colombia   | Sao Paulo         | Online and Phone | 448   | 42     | 19     |
| Costa Rica | Sao Paulo         | Online and Phone | 412   | 44     | 20     |
| Ecuador    | Sao Paulo         | Online and Phone | 507   | 43     | 18     |
| Mexico     | Sao Paulo         | Online and Phone | 464   | 41     | 17     |
| Panama     | Sao Paulo         | Online and Phone | 291   | 50     | 19     |
| Peru       | Sao Paulo         | Online and Phone | 248   | 44     | 9      |
| *TOTAL*    |                   | Online and Phone | 3803  | 446    | 161    |
|            |                   |                  |       |        |        |
| Argentina  |                   | Online Only      | 517   |        | 19     |
| Bolivia    |                   | Online Only      | 132   |        | 12     |
| Brazil     |                   | Online Only      | 1183  |        | 52     |
| Chile      |                   | Online Only      | 470   |        | 31     |
| Colombia   |                   | Online Only      | 522   |        | 29     |
| Costa Rica |                   | Online Only      | 325   |        | 20     |
| Ecuador    |                   | Online Only      | 460   |        | 37     |
| Mexico     |                   | Online Only      | 955   |        | 29     |
| Panama     |                   | Online Only      | 319   |        | 26     |
| Peru       |                   | Online Only      | 540   |        | 25     |
| *TOTAL*    |                   | Online Only      | 5569  |        | 293    |
Table: Survey response rates.

The response rate was 10.24 percent of the original population in the telephone survey (779 of 7606 possible respondents). We had an attrition of 61.62 percent from the telephone (779) to the online survey (299). The response rate for the online only survey was 5.26 percent (293 of 5569 invited by email).

The conjoint experiment analyzed in this paper was in the online and online-only dataset. Therefore, the relevant column for our data is the last one.

## Allocation Methods

**Random Assignment:** We programmed the experiment using a Python application provided by @strezhnev2013conjoint. We translated the original survey questions (as shown in the text) into Portuguese and Spanish, and then embedded the PHP file with the randomization parameters in a Qualtrics survey. The PHP code we used to randomize the values of the attributes is available at the project's GitHub repository: <http://github.com/danilofreire/climate-governance>.

For each attribute, the probability of selecting a given component follows a uniform distribution function. The table below describes the results.

\vspace{.5cm}

| **Attribute**                          | **Values**                                   | **Probabilities** |
|:---------------------------------------|:---------------------------------------------|------------------:|
| **Who makes the rules?**               | International organizations                  | 1/5               | 
|                                        | Federal government                           | 1/5               |
|                                        | Local government                             | 1/5               |
|                                        | Local community members                      | 1/5               |
|                                        | Non-governmental organizations               | 1/5               |
|                                        |                                              |                   |
| **Conflict resolution mechanism**      | United Nations                               | 1/5               |
|                                        | Government bureaucracy                       | 1/5               |
|                                        | Local courts                                 | 1/5               |
|                                        | Private arbitration                          | 1/5               |
|                                        | Informal norms                               | 1/5               |
|                                        |                                              |                   |
| **Punishment**                         | Imprisonment                                 | 1/4               |
|                                        | Fines                                        | 1/4               |
|                                        | Blacklist                                    | 1/4               |
|                                        | None                                         | 1/4               |
|                                        |                                              |                   |
| **Punishment for repeated violations** | More penalty                                 | 1/3               |
|                                        | Same                                         | 1/3               |
|                                        | Less penalty                                 | 1/3               |
|                                        |                                              |                   |
| **Agreement costs**                    | Rich countries pay more than poor countries  | 1/4               |
|                                        | Proportional to history of emissions         | 1/4               |
|                                        | Proportional to current emissions            | 1/4               |
|                                        | Only rich countries pay                      | 1/4               |
|                                        |                                              |                   |
| **Renegotiation**                      | Never                                        | 1/5               |
|                                        | Fifty years                                  | 1/5               |
|                                        | Twenty years                                 | 1/5               |
|                                        | Five years                                   | 1/5               |
|                                        | One year                                     | 1/5               |
Table: Conjoint experiment attributes and their respective probabilities.

We added one logical restriction to the set climate change treaties: **Punishment = None** can never appear together with **Punishment for repeated violations = Less penalty**. The number of possible treaties are the product of the attributes ($5\times 5 \times 4 \times 3 \times 4 \times 5 = 6,000$) minus the number of removed possibilities ($5\times 5  \times 4 \times 5 = 500$). The total number of possible treaties is $5,500$.

## Treatments

**Descriptions of the intervention:** Our treatment was the randomization of components in the conjoined climate mitigation treaties. We provided the following description before the conjoint experiment starts, in Spanish and Portuguese:

\vspace{.5cm}

```
For the following questions, read carefully the instructions below.
 
Imagine that your country would sign an international treaty to mitigate climate change. 
A climate mitigation treaty has, in general, the following attributes:
 
1. Who defines the rules? Which group will define the parameters for the treaty?
2. How are the conflicts that might happen when the treaty begin be resolved?
3. What punishments should be applied to ensure compliance?
4. How will repeated violations be punished?
5. How are costs for implementing the treaty be distributed?
6. How often the treaty has to be renegotiated?

In the following questions, you will see variations in treaties on these six attributes.
Please select the treaty that has the characteristics that you believe are best for your country.
```

\vspace{.5cm}

The conjoint experiment consisted in comparing two treaties that vary in these six attributes, repeating the application for seven times for each respondent.

\noindent \textbf{Software:} To program the PHP randomization device we used the Python application provided by @strezhnev2013conjoint. We used Qualtrics to administer the survey.

\noindent \textbf{Delivery:} We repeated the conjoint experiment seven times, to improve test power.

\noindent \textbf{Dataset description:} Each line in the dataset represents a given treaty, varying for the selection status (selected versus non-selected) for a given respondent. When a respondent finished an entire response set, this adds 14 rows to the dataset. Seven rows with the selected treaties and other seven rows with the non-selected treaties.

\noindent \textbf{Deception:} We used no deception in this survey experiment.

## Results

\noindent \textbf{Outcome measures and covariates:} The main outcome is a binary indicator for the selection of a given conjoined package. We added two covariates to measure heterogeneous effects: *Country* and *Elite type*.

\noindent \textbf{Questionnaire:} For the English translation of the entire survey instrument, with both the telephone and the online components, see the attachment below.

\noindent \textbf{Statistical analysis:} We fit a marginal means estimator and an AMCE estimator. The estimation conditions the results within subjects and the presented conjoined packages. The results are available in sections \ref{sec:features} and \ref{sec:amce}.

\noindent \textbf{Missing data and attrition:} Conditional on having started the conjoint experiment, for each task we had the following completion rates:

```{r, fig.width = 7, fig.height = 8}
barplot(100*table(cj$task)/max(table(cj$task)), xlab = 'Conjoint task', ylab = 'Percentage completed')
```

## Other information

\noindent \textbf{IRB:} This research received IRB approval from Brown University (Protocol 2195/2018) and Funda\c{c}\~{a}o Get\'{u}lio Vargas (Protocol 83/2018).

\noindent \textbf{Pre-registration:} The result was not pre-registered.

\noindent \textbf{Funding:} The research was funded by Konrad Adenauer Stiftung (KAS). KAS provided EUR$ 55,000.00 for this research. They have not interfered in the research design and in the question choices.

\noindent \textbf{Replication materials:} Available at <http://github.com/danilofreire/climate-governance>.

# Bibliography